Domain Driven Design: approche de conception basée sur le métier
Il s'agit de représenter le métier directement dans le code, plutôt que de coder le métier.

Etape importante: définir un vocabulaire commun à l'ensemble des participants:
Ubiquitous Language  vocabulaire commun à l'ensemble des participants.
Sert à éliminer toute ambiguité possible et s'assurer que le domaine métier est bien assimilé par tous.
Comment le définir: l'ensemble des participants se mettent d'accord sur les termes et les concepts qui seront utilisés.
Une documentation est générée à l'issue de cette étape.
Ex: application e-commerce - Customer - Order - Product -> ne pas utiliser d'autres termes dans le code

Ses termes doivent être utilisés par tout dans le code: package, classes, méthodes, instructions des méthodes, nom des

Anemic Domain Model vs. Rich Domain Model:

Une approche classique (basée sur les données) utilise des objets (anemic) ne contenant que des attributs + getter/setter
Une approche basée sur le métier, utilise des objets contenant des méthodes métier (remplacer les appels vers les get/set)
par des méthodes métier (utiliser tell don't ask + demeter)

Microsoft recommande DDD lorsque le domaine métier est complèxe et à besoin d'être très bien compris par l'ensemble des participants.

>>> Pourquoi l'utiliser:
- Quand l'application est techniquement complèxe ou que son métier l'est
- S'il y'à un haut risque dans le métier(banque, défense....)

>>>> Pourquoi ne pas l'utiliser:
-  Pour un simple CRUD
- s'il s'agit de gérer du contenu (CMS - Cie)
- Une application techniquement simple
- Un domaine métier générique ou peu de compléxité métier
- Une équipe de dév. trop jeunes